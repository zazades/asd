local char = game.Players.LocalPlayer.Character

local humrp = char.HumanoidRootPart

local chair
local deb
local deb2

local resource = game.Workspace.Deployables

local findC = {}
task.spawn(function()
    game.Workspace.Deployables.ChildAdded:Connect(function(child)
        if child.Name == "Chair" then
	    child.ModelStreamingMode = "Default"
            table.insert(findC, v) 
        end
    end)
    for i,v:Instance in pairs(workspace.Deployables:GetChildren()) do
        if v.Name == "Chair" and v:FindFirstChild("Seat") then
            local trgt = v:FindFirstChild("Reference")
		v.ModelStreamingMode = "Default"
                table.insert(findC, v)
        end
    end
end)

local function addResourceC()
    for i, v in pairs(resource:GetChildren()) do
        if v.Name == "Chair" and v:FindFirstChild("Seat") then
            local trgt = v:FindFirstChild("Reference")
            
		v.ModelStreamingMode = "Default"
                table.insert(findC, v)
            
        end
    end
end

local function findTargetC()
    local resource = game.Workspace.Resources:GetChildren()
    local MaxDistance = math.huge
    local nearestTarget
    local golds = findC
    if #golds == 0 then addResourceC() end
    for _, goldNode in ipairs(golds) do
        if goldNode and goldNode:FindFirstChild("Seat") then
            local target = goldNode:FindFirstChild("Seat")
            local distance = (humrp.Position - target.Position).Magnitude

            if distance < MaxDistance then
                nearestTarget = target
                MaxDistance = distance
            end
        end
    end

    return nearestTarget 
end

local function teleport()
    if deb then return end
    chair = findTargetC()
    if not chair then addResourceC() chair = findTargetC() end
    deb = true
    
    chair.CFrame = humrp.CFrame * CFrame.new(0,1.5,0)
    task.wait(1)
    chair.CFrame = humrp.CFrame * CFrame.new(0,15,0)
    task.wait(2.5)
    chair.CFrame = humrp.CFrame * CFrame.new(0,0,0)
    repeat wait() until char.Humanoid.SeatPart ~= nil
    
    humrp.CFrame = chair.CFrame * CFrame.new(0,25,0)
    task.wait(0.2)
    chair.CFrame = chair.CFrame * CFrame.new(0,25,0)

    char.Humanoid.Sit = false
    
    task.wait(0.2)
    char.Humanoid.Sit = true
    task.wait(0.2)
    char.Humanoid.Sit = false
    deb = false
end


local function closeResource(position)
    for _, resource in ipairs(game.Workspace.Resources:GetChildren()) do
        if resource.Name == "Gold Node" and resource:FindFirstChild("Reference") then 
            local tar = resource:FindFirstChild("Reference")
            if (tar.Position - position).Magnitude < 10 then
		
                return true
            end
        end
    end

    return false
end


local dep = workspace.Deployables
local function closePart()
        wait()
        if closeResource(humrp.Position) then
            for i, v in pairs(find) do
                if v.Name == "Chair" and v:FindFirstChild("Seat") then
                    if (v:FindFirstChild("Part").Position - humrp.Position).magnitude < 10 then
                        table.remove(findC, i)
                        print(i)
                    end
                end
            end
        else
            print("elsed")
            for i, v in pairs(findC) do
                if v.Name == "Chair" and v:FindFirstChild("Seat") then
                    if (v:FindFirstChild("Part").Position - humrp.Position).magnitude < 10 then
                        print("hi")
                        table.remove(findC, i)
                        print(i)
                    end
                end
            end
            teleport() 
        end
end

local RunService = game:GetService('RunService')
local PathfindingService = game:GetService('PathfindingService')
local c = game.Players.LocalPlayer.Character
local hum = c.Humanoid
hum.MaxSlopeAngle=90
local humrp = c.HumanoidRootPart
local Animator = hum.Animator
local resource = game.Workspace.Resources
local root = c.HumanoidRootPart
local find = {}
local stop = false

local rs = game:GetService("RunService")
task.spawn(function()
    game.Workspace.Resources.ChildAdded:Connect(function(child)
        if child.Name == "Gold Node" then
            table.insert(find, child) 
        end
    end)
    for i,v:Instance in pairs(workspace.Resources:GetChildren()) do
        if v.Name == "Gold Node" and v:FindFirstChild("Reference") then
		
            local trgt = v:FindFirstChild("Reference")
           
                table.insert(find, v)
            
        end
    end

     for i,v:Instance in pairs(workspace.Resources:GetChildren()) do
        if v.Name == "Ice Chunk" and v:FindFirstChild("Gold Node") then
            local trgt = v:FindFirstChild("Gold Node"):FindFirstChild("Reference")
           
                table.insert(find, v)
           
        end
    end
end)

local function addResource()
    for i, v in pairs(resource:GetChildren()) do
        if v.Name == "Gold Node" and v:FindFirstChild("Reference") then
            local trgt = v:FindFirstChild("Reference")
             
                table.insert(find, v)
           
        end
    end
     for i,v:Instance in pairs(workspace.Resources:GetChildren()) do
        if v.Name == "Ice Chunk" and v:FindFirstChild("Gold Node") then
            local trgt = v:FindFirstChild("Gold Node"):FindFirstChild("Reference")
          
                table.insert(find, v)
            
        end
    end
end


local function getMover(part)
    for _, descendant in pairs(part:GetDescendants()) do
        if not descendant:IsA("BasePart") then
            continue
        end
        local originalCFrame = descendant.CFrame
        descendant.CFrame = CFrame.new()
        if descendant.CFrame == CFrame.new() then
            descendant.CFrame = originalCFrame
            return descendant
        end
    end
end

local function getMovePart()
    if not root then
        return nil
    end
    if not (hum and root and hum.SeatPart and hum.SeatPart.Parent) then
        return root
    end
    return getMover(hum.SeatPart.Parent) or root
end


local function findTarget()
    local resource = game.Workspace.Resources:GetChildren()
    local MaxDistance = math.huge
    local nearestTarget
    local golds = find
    for _, goldNode in ipairs(golds) do
        if goldNode and goldNode:FindFirstChild("Reference") then
            local target = goldNode:FindFirstChild("Reference")
            local distance = (humrp.Position - target.Position).Magnitude

            if distance < MaxDistance then
                nearestTarget = target
                MaxDistance = distance
            end
        end
    end

    return nearestTarget 
end

local lastPathTime = 0
local pathRefreshDelay = 1 -- Adjust as needed
local cachedPaths = {}
local function shouldRefreshPath()
    return os.time() - lastPathTime >= pathRefreshDelay
end

local function createPath(destination)
    if not shouldRefreshPath() then
        return cachedPaths[destination] or cachedPaths.default
    end

    local pathFound = false
    local path

    repeat
        wait()
        destination = findTarget()
        if destination then
            path = PathfindingService:CreatePath({AgentHeight = 1})
            local success, err = pcall(function()
                path:ComputeAsync(humrp.Position, destination.Position)
            end)
            if success then
                if path.Status == Enum.PathStatus.Success then
                    pathFound = true
                    cachedPaths[destination] = path
                    addResource()
                else
                    for i, v in ipairs(find) do
                        if v == destination.Parent then
                            table.remove(find, i)
                            if #find == 0 then
                                path:ComputeAsync(humrp.Position, Vector3.new(-98.7, -3, 78))
                                pathFound = true
                                cachedPaths.default = path
                                addResource()
                            end
                        end
                    end
                end
            else
                print("Error during path computation:", err)
            end
        else
            path = PathfindingService:CreatePath({AgentHeight = 1})
            path:ComputeAsync(humrp.Position, Vector3.new(-98.7, -3, 78))
            pathFound = true
            cachedPaths.default = path
            addResource()
        end
    until pathFound

    lastPathTime = os.time()
    return path
end

local function closeResource(position)
    for _, resource in ipairs(game.Workspace.Resources:GetChildren()) do
        if resource.Name == "Gold Node" and resource:FindFirstChild("Reference") then 
            local tar = resource:FindFirstChild("Reference")
            if (tar.Position - position).Magnitude < 3 then
                return true
            end
        end
    end

    return false
end

local function closeResourceC(position)
    for _, resource in ipairs(game.Workspace.Resources:GetChildren()) do
        if resource.Name == "Chair" and resource:FindFirstChild("Seat") then 
            local tar = resource:FindFirstChild("Seat")
            if (tar.Position - position).Magnitude < 10 then
                return resource
            end
        end
    end
end

local function findI()
 for _, resource in ipairs(game.Workspace.Resources:GetChildren()) do
        if resource.Name == "Chair" and resource:FindFirstChild("Seat") then 
            local tar = resource:FindFirstChild("Seat")
            if (tar.Position - position).Magnitude < 10 then
                return i
            end
        end
    end
end

local function moveTo(pos:CFrame)
	if not getMovePart() then return end
	if typeof(pos)=="Vector3" then pos = CFrame.new(pos) end
	local move=getMovePart()
	local dif = (move.CFrame.Position-root.CFrame.Position)
	move.CFrame = pos+dif
end

local function moveTowards(destination, rate, reenable, validator, height)
    local path = createPath(destination)
    if not path then
     
        return
    end
    local waypoints = path:GetWaypoints()
    local currentPositionIndex = 1

    local function teleportTo(pos)
    end

    local function walkTo(destination)
        local humrp = root
        if not humrp then
            
            return
        end

        local uzak = (humrp.Position - destination).Magnitude
        while uzak > 3 do
            local distanceToDestination = (destination - humrp.Position).Magnitude
            if distanceToDestination < 3 then
		 if closeResourceC() then
		    local remve = closeResourceC()
		    repeat until not closeResource()
		    table.remove(findC, findI())
		end
		return
            end

            local currentWaypoint = waypoints[currentPositionIndex]
            local nextWaypoint = waypoints[currentPositionIndex + 1]

            if nextWaypoint then
                local direction = (nextWaypoint.Position - humrp.Position).Unit
                local distanceToNextWaypoint = (nextWaypoint.Position - humrp.Position).Magnitude
                local steps = math.ceil(distanceToNextWaypoint / rate)

                for step = 0.1, steps do
                    direction = (nextWaypoint.Position - humrp.Position).Unit
                    local ehe = getMovePart()
                    local localDirection = ehe.CFrame:VectorToObjectSpace(direction)
                    local adjustedRate = math.min(rate, distanceToNextWaypoint)

                    local newCFrame = humrp.CFrame * CFrame.new(
                        localDirection.X * adjustedRate,
                        localDirection.Y * adjustedRate * 0.5,
                        localDirection.Z * adjustedRate
                    )
                    ehe.CFrame = newCFrame
                    wait()
                end
            else
              
                break
            end

            currentPositionIndex = currentPositionIndex + 1
            end
    end

    walkTo(destination)
end

_G.Rate = 0.8
local function call()
    local closestPart = findTarget()
    if closestPart then
        local movementRate = _G.Rate -- Example movement rate
        local reenable = true -- Example reenable parameter
        local validator = function() return true end -- Example validator function
        local height = 9 -- Example height parameter
        local destination = closestPart.Position
	if (destination - humrp.Position).magnitude < 3 then  addResource() return end
	if not destination then return end
        moveTowards(destination, movementRate, reenable, validator, height)
        addResource()
    else
       
    end
end

local function closeResource2(position)
    for _, resource in ipairs(game.Workspace.Resources:GetChildren()) do
        if resource.Name == "Gold Node" and resource:FindFirstChild("Reference") then 
            local tar = resource:FindFirstChild("Reference")
            if (tar.Position - position).Magnitude < 100 then
                return true
            end
        end
    end

    return false
end

while true do wait()
    if closeResource2(humrp.Position) then
	call()
    else
	closePart()
    end
end

