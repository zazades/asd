local RunService = game:GetService('RunService')
local PathfindingService = game:GetService('PathfindingService')
local c = game.Players.LocalPlayer.Character
local hum = c.Humanoid
hum.MaxSlopeAngle=90
local humrp = c.HumanoidRootPart
local Animator = hum.Animator
local resource = game.Workspace.Resources
local root = c.HumanoidRootPart
local find = {}
local stop = false

local rs = game:GetService("RunService")
task.spawn(function()
    game.Workspace.Resources.ChildAdded:Connect(function(child)
        if child.Name == "Gold Node" then
		    child.ModelStreamingMode = "Default"
	    local trgt = child:FindFirstChild("Reference")
		if trgt.CFrame.Y > -30 and trgt.CFrame.Y < 100 then
            table.insert(find, child) 
		end
        end
    end)
    for i,v:Instance in pairs(workspace.Resources:GetChildren()) do
        if v.Name == "Gold Node" and v:FindFirstChild("Reference") then
		
            local trgt = v:FindFirstChild("Reference")
           if trgt.CFrame.Y > -30 and trgt.CFrame.Y < 100 then
		v.ModelStreamingMode = "Default"
		
                table.insert(find, v)
		if trgt.CFrame.Y < -30 then v:Destroy() table.remove(find,v) end
            end
        end
    end

     for i,v:Instance in pairs(workspace.Resources:GetChildren()) do
        if v.Name == "Ice Chunk" and v:FindFirstChild("Gold Node") then
            local trgt = v:FindFirstChild("Gold Node"):FindFirstChild("Reference")
           if trgt.CFrame.Y > -30 and trgt.CFrame.Y < 100 then
		v.ModelStreamingMode = "Default"
                table.insert(find, v)
		if trgt.CFrame.Y < -30 then v:Destroy() table.remove(find,v) end
            end
        end
    end
end)

local function addResource()
    for i, v in pairs(resource:GetChildren()) do
        if v.Name == "Gold Node" and v:FindFirstChild("Reference") then
            local trgt = v:FindFirstChild("Reference")
             if trgt.CFrame.Y > -35 and trgt.CFrame.Y < 85 then
		v.ModelStreamingMode = "Default"
                table.insert(find, v)
		if trgt.CFrame.Y < -30 then v:Destroy() table.remove(find,v) end
            end
        end
    end
     for i,v:Instance in pairs(workspace.Resources:GetChildren()) do
        if v.Name == "Ice Chunk" and v:FindFirstChild("Gold Node") then
            local trgt = v:FindFirstChild("Gold Node"):FindFirstChild("Reference")
           if trgt.CFrame.Y > -30 and trgt.CFrame.Y < 100 then
		v.ModelStreamingMode = "Default"
                table.insert(find, v)
		if trgt.CFrame.Y < -30 then print("destroyed some") v:Destroy() table.remove(find,v) end
            end
        end
    end
end


local function getMover(part)
    for _, descendant in pairs(part:GetDescendants()) do
        if not descendant:IsA("BasePart") then
            continue
        end
        local originalCFrame = descendant.CFrame
        descendant.CFrame = CFrame.new()
        if descendant.CFrame == CFrame.new() then
            descendant.CFrame = originalCFrame
            return descendant
        end
    end
end

local function getMovePart()
    if not root then
        return nil
    end
    if not (hum and root and hum.SeatPart and hum.SeatPart.Parent) then
        return root
    end
    return getMover(hum.SeatPart.Parent) or root
end


local function findTarget()
    local resource = game.Workspace.Resources:GetChildren()
    local MaxDistance = math.huge
    local nearestTarget
    local golds = find
    for _, goldNode in ipairs(golds) do
        if goldNode and goldNode:FindFirstChild("Reference") then
            local target = goldNode:FindFirstChild("Reference")
            local distance = (humrp.Position - target.Position).Magnitude

            if distance < MaxDistance then
                nearestTarget = target
                MaxDistance = distance
            end
        end
    end

    return nearestTarget 
end

local lastPathTime = 0
local pathRefreshDelay = 1 -- Adjust as needed
local cachedPaths = {}
local function shouldRefreshPath()
    return os.time() - lastPathTime >= pathRefreshDelay
end

local function createPath(destination)
    if not shouldRefreshPath() then
        return cachedPaths[destination] or cachedPaths.default
    end

    local pathFound = false
    local path

    repeat
        wait()
        destination = findTarget()
        if destination then
            path = PathfindingService:CreatePath({AgentHeight = 1})
            local success, err = pcall(function()
                path:ComputeAsync(humrp.Position, destination.Position)
            end)
            if success then
                if path.Status == Enum.PathStatus.Success then
                    pathFound = true
                    cachedPaths[destination] = path
                    addResource()
                else
                    for i, v in ipairs(find) do
                        if v == destination.Parent then
                            table.remove(find, i)
                            if #find == 0 then
                                path:ComputeAsync(humrp.Position, Vector3.new(-98.7, -3, 78))
                                pathFound = true
                                cachedPaths.default = path
                                addResource()
                            end
                        end
                    end
                end
            else
                print("Error during path computation:", err)
            end
        else
            path = PathfindingService:CreatePath({AgentHeight = 1})
            path:ComputeAsync(humrp.Position, Vector3.new(-98.7, -3, 78))
            pathFound = true
            cachedPaths.default = path
            addResource()
        end
    until pathFound

    lastPathTime = os.time()
    return path
end

local function closeResource(position)
    for _, resource in ipairs(game.Workspace.Resources:GetChildren()) do
        if resource.Name == "Gold Node" and resource:FindFirstChild("Reference") then 
            local tar = resource:FindFirstChild("Reference")
            if (tar.Position - position).Magnitude < 3 then
                return true
            end
        end
    end

    return false
end


local function moveTo(pos:CFrame)
	if not getMovePart() then return end
	if typeof(pos)=="Vector3" then pos = CFrame.new(pos) end
	local move=getMovePart()
	local dif = (move.CFrame.Position-root.CFrame.Position)
	move.CFrame = pos+dif
end

local function moveTowards(destination, rate, reenable, validator, height)
    local path = createPath(destination)
    if not path then
     
        return
    end
    local waypoints = path:GetWaypoints()
    local currentPositionIndex = 1

    local function teleportTo(pos)
    end

    local function walkTo(destination)
        local humrp = root
        if not humrp then
            
            return
        end

        local uzak = (humrp.Position - destination).Magnitude
        while uzak > 3 do
            local distanceToDestination = (destination - humrp.Position).Magnitude
            if distanceToDestination < 3 then
                teleportTo(destination)
                return
            end

            local currentWaypoint = waypoints[currentPositionIndex]
            local nextWaypoint = waypoints[currentPositionIndex + 1]

            if nextWaypoint then
                local direction = (nextWaypoint.Position - humrp.Position).Unit
                local distanceToNextWaypoint = (nextWaypoint.Position - humrp.Position).Magnitude
                local steps = math.ceil(distanceToNextWaypoint / rate)

                for step = 1, steps do
                    direction = (nextWaypoint.Position - humrp.Position).Unit
                    local ehe = getMovePart()
                    local localDirection = ehe.CFrame:VectorToObjectSpace(direction)
                    local adjustedRate = math.min(rate, distanceToNextWaypoint)

                    local newCFrame = humrp.CFrame * CFrame.new(
                        localDirection.X * adjustedRate,
                        localDirection.Y * adjustedRate * 0.5,
                        localDirection.Z * adjustedRate
                    )
                    ehe.CFrame = newCFrame
                    wait()
                end
            else
              
                break
            end

            currentPositionIndex = currentPositionIndex + 1
            if currentPositionIndex > #waypoints then
                addResource()
                local newPath = findTarget()
                if newPath then
                    path = createPath(newPath)
                    if not path then
                        
                        break
                    end
                    waypoints = path:GetWaypoints()
                    currentPositionIndex = 1
                else
                    
                    break
                end
            end
        end
    end

    walkTo(destination)
end
local function call()
    local closestPart = findTarget()
    if closestPart then
        local movementRate = _G.Rate 
        local reenable = true
        local validator = function() return true end
        local height = 9
        local destination = closestPart.Position
        if not destination then
            
            return
        end
        moveTowards(destination, movementRate, reenable, validator, height)
        addResource()
    else
       
    end

task.spawn(function()
    while _G.Start do
        wait()
        if stop then 
            wait()
        else
            call()
        end
    end
end)
    walkTo(destination)
end

local function call()
    local closestPart = findTarget()
    if closestPart then
        local movementRate = _G.Rate -- Example movement rate
        local reenable = true -- Example reenable parameter
        local validator = function() return true end -- Example validator function
        local height = 9 -- Example height parameter
        local destination = closestPart.Position
	
	if not destination then return end
        moveTowards(destination, movementRate, reenable, validator, height)
        addResource()
    else
       
    end
end

task.spawn(function()
    while _G.Start do
        wait()
        if stop then 
            wait()
        else
            call()
        end
    end
end)
